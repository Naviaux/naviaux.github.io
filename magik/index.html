<!-- var myWindow = window.open("", "", "width=200,height=100"); -->

<html>
	<head>
		<title>Mageiks</title>
		<link rel="stylesheet" type="text/css" href="mage.css" />
		<script src="http://code.jquery.com/jquery-3.4.1.js"></script>
		<script src="./mage.js"></script>
		<script>
			$(document).ready ( function() {
			
				function addStatusEffect (spell, effect, target) {
					var type = effect[0].split(".")[0];
					var name = effect[0].split(".")[1];
					switch (name) {
						case "stun":
							if (!target.status[type][name][spell])
								target.status[type][name][spell] = {
									effect : effect[1],
									duration : effect[2],
								}
							break;
						default: 
							target.status[type][name][spell] = {
								effect : effect[1],
								duration : effect[2],
							}
					}
				}
			
				game.enemy = {
					stats : {
						hp : {
							current : 100,
							max : 100,
							regen : {
								amount : 1,
								is : true,
								delay : 20,
								interval : 2,
								counter : 0,
							}
						},
						mana : {},
						attack : {
							damage : 1,
							speed : 25,
							counter : 0,
							delay : 0,
						}
					},
					status : {
						negative : { // S - Stack, H - Highest Only, R - Refreshes, E - Expire
							slow : { // delays attacks by effect - SR
								/*0: { // key indicates source spell
									effect : 1, // status effectiveness
									duration : 10, // status effect duration left
								}*/
							},
							stun : {}, // prevents attacks from coming - HE
							enfeeble : {}, // reduces damage by percentage - HR
							weakness : {}, // reduces damage by flat - SR
							curse : { }, // increases damage taken by percentage - HR
							dot : { } // deals damage overtime - SR
						}
					}
				};
			
		/*		game.enemy = {};
				game.enemy.stats = {};
				game.enemy.stats.hp = {};
				game.enemy.stats.hp.current = 10;
				game.enemy.stats.hp.max = 10;
				game.enemy.attack = {};
				game.enemy.attack.speed = 25;
				game.enemy.attack.damage = 1;
				game.enemy.attack.delay = 0;*/
				
				game.mechanics = {}
				game.mechanics.tick = 0;
				game.mechanics.tick_rate = 100;
				game.mechanics.enemy_respawn_ticks = 0;
				game.mechanics.respawn_delay = 0;
				game.mechanics.refresh_delay = -1;
				
				game.player.activeTab = RESEARCHING;
				game.player.currentConstruction = false;
				
				$(".slot").click(function (e) { // When a spell slot is clicked
					var spellID = e.currentTarget.id;
					var spellSlot = game.player.spells[spellID]; // grab which spell slot was clicked
					if (spellSlot.unlocked) { // check to see if the spell slot is unlocked
						var mana = game.player.stats.mana;
						var enemy = game.enemy.stats; // game scope storage
						
						game.player.currentAction = FIGHTING; // sets player action to fighting
						
						var spell = calculateSpellAttributes(spellSlot.attributes); // gets the attributes of the spell slot
						/* this is temporary and should be changed in the future */
						/* TODO: Update to make minimum safetyNet value equal to magic.arcana.primaryCost - likely in a different function */
						(game.player.safetyNet <= spell.cost) ? game.player.safetyNet = spell.cost : 0;
						
						/* this needs to change based on the spell, this only works for offensive spells */
						/* TODO: cast spell based on effects */
						if (mana.current >= spell.cost && enemy.hp.current > 0) {
							mana.increaseCounter += spell.cost; 
							mana.current -= spell.cost;
							enemy.hp.current -= spell.damage;
							if (spell.effects.length > 0)
								for (var effect of spell.effects)
									addStatusEffect(spellID, effect, game.enemy);
						}
					}
					update(false); // calls a UI update
				});
				
				/* 
					Grabs the attributes a spell
						Array attributes: Array of Strings containing keys from magics
						
					TODO: Implement multiple magic types and effects
					TODO: Make attributes objects instead of Strings
				*/
				function calculateSpellAttributes(attribute) {
					var magics = game.player.magics;
					var attributes = Object.create(attribute);
					var damage = magics[attributes[0]].primary.damage;
					var cost = magics[attributes[0]].primary.cost;
					var effects = new Array();
					if (magics[attributes[0]].primary.effects)
						for (let effect_list of magics[attributes[0]].primary.effects)
							effects.push(effect_list);
						
					attributes.shift();
					if (attributes.length > 0) {
						for (var key of attributes) {
							damage *= magics[key].secondary.damage;
							cost *= magics[key].secondary.cost
							if (magics[key].secondary.effects)
								for (let effect_list of magics[key].secondary.effects)
									effects.push(effect_list);
						//	magics[key].secondary.effects ? effects.push ( magics[key].secondary.effects ) : null;
						}
					}
					return { damage : damage, cost : cost, effects : effects };
				};
				
				/*
					Grabs the UI for the currently active tab
					
				*/
				function getActiveTabUI (tab) {
					var toAdd = "";
					for (var item in tab) {
						var hasReqs = true;
						for (var reqs in tab[item].requirements) {
							if (!tab[item].requirements[reqs]()) {
								hasReqs = false;
								break;
							}
						}
						if (hasReqs && !(tab[item].count >= tab[item].max)) {
							toAdd += '<div id="' + item.replace(/ /g, "_") + '">' + item + ' ' + tab[item].count + ' ' + Math.ceil(tab[item].Progress) + '/' + Math.ceil(tab[item].Time) + '</div>';
						}
					}
					return toAdd;
				}
				
				function getStatusEffect(target, effect) {
					var type = effect.split(".")[0];
					var name = effect.split(".")[1];
					var effectiveness = 0;
					for (let e in target.status[type][name]) {
						switch (name){
							case "stun":
							case "enfeeble":
							case "curse":
								if (target.status[type][name][e].effect > effect)
									effectiveness = target.status[type][name][e].effect;
								break;
							default: 
								effectiveness += target.status[type][name][e].effect;
						}
						if (--target.status[type][name][e].duration <= 0)
							delete target.status[type][name][e];
					}
					return effectiveness;
				}
				
				/*
					Loops through the game and updates various states
						NYI boolean onlyUIUpdate: only causes the UI to update
				*/
				function update( onlyUIUpdate ) {
					var enemy = game.enemy.stats;
					var player = game.player.stats;
					var mechanics = game.mechanics; // game scopes
					
					mechanics.tick++; // keeps track of current tick
					
					if (enemy.hp.current <= 0) { // if the enemy has less than 0 health
						enemy.hp.current = 0; // sets enemy's health to 0 (this is to prevent negative numbers from occurring on the UI)
						mechanics.respawn_delay++; // increases the respawn delay of the enemy
						if (mechanics.respawn_delay >= mechanics.enemy_respawn_ticks) { // if the enemy can respawn
							enemy.hp.current = enemy.hp.max; // resets some values
							enemy.attack.counter = 0;
							mechanics.respawn_delay = 0;
						}
					} else { // if the enemy has health
						if (!getStatusEffect(game.enemy, "negative.stun") > 0)
							enemy.attack.counter++;  // increase enemy attack counter
						if (game.player.currentAction == FIGHTING) { // if the player is fighting
							if (enemy.attack.counter >= enemy.attack.speed + getStatusEffect(game.enemy, "negative.slow")) { // if the enemy's attack counter exceeds it's attack speed value
								player.hp.current -= enemy.attack.damage ; // deal damage to player
								enemy.attack.counter = 0; // reset enemy attack counter
							}
						} else { // if the player is not fighting then make the enemy attack immediately
							enemy.attack.counter += enemy.attack.speed; // this is to prevent attack exploits
						}
					}
					
					if (player.mana.current > player.mana.max) // resets player's mana to max if it's greater than max mana
						player.mana.current = player.mana.max;
					
					if (player.mana.increaseCounter >= player.mana.increaseRequired) { // if the player has used enough mana to cause an increase
						player.mana.max += player.mana.increaseAmount; // increase max mana
						player.mana.increaseCounter = 0; // reset counter
					}
					
					player.mana.regenCounter++;
					if (player.mana.regenCounter >= player.mana.regenDelay && game.player.currentAction != CONSTRUCTING) { // if the player has a mana regen tick and is not constructing
						player.mana.current += player.mana.regenFlat; // add the flat regen amount to current mana
						player.mana.current += player.mana.max * player.mana.regenMax; // add the max regen amount to current mana
						player.mana.regenCounter = 0; // reset the regen counter
						if (player.mana.current >= player.mana.max) { // keeps player's mana at or under max mana
							player.mana.current = player.mana.max;
						}
					}
					
					if (game.player.currentAction == RESEARCHING) { // if the player is researching
						game.research[game.player.currentResearch].Progress += player.research.progress * player.research.progressMultiplier; // adds progress to the research
						if (game.research[game.player.currentResearch].Progress >= game.research[game.player.currentResearch].Time) { // if the progress exceeds to time
							game.research[game.player.currentResearch].Progress = onResearch(game.player.currentResearch) ? 0 : game.research[game.player.currentResearch].Time; // if the player doesn't break the research safetys, reset the progress, otherwise set progress to time
							game.player.currentAction = IDLE; // set player's action to idle
							game.mechanics.refresh_delay = -1; // forces a ui update this tick
						}
					}
					if (game.player.currentAction == CONSTRUCTING) { // if the player is constructing
						player.construction.delay++; // keeps track of construction speed
						if (player.construction.delay >= player.construction.speed) {
							game.construct[game.player.currentConstruction].Progress += player.construction.progress * player.construction.progressMultiplier; // adds progress to construction
							player.construction.delay = 0;
						}
						if (game.player.currentConstruction && game.construct[game.player.currentConstruction].Progress >= game.construct[game.player.currentConstruction].Time) { // if progress exceeds time
							onConstruct (game.player.currentConstruction); // construct the object
							game.construct[game.player.currentConstruction].Progress = 0;
							game.player.currentAction = IDLE;
							game.player.currentConstruction = false;
							game.mechanics.refresh_delay = -1; // reset stuff and force ui update
						}
					} else {
						player.construction.delay = 0; // reset construction counter to prevent construction abuse
					}
					if (game.mechanics.refresh_delay % 4 == 0 || game.mechanics.refresh_delay == -1) { // if ui can update
						if (game.player.activeTab == RESEARCHING) { // if current tab is research
							$("#menu_options").html( getActiveTabUI(game.research) ); // load research ui
							/*() => { backup function
								var research = game.research;
								var toAdd = "";
								for (var r in research) {
									var hasReqs = true;
									for (var reqs in research[r].requirements) {
										if (!research[r].requirements[reqs]()) {
											hasReqs = false;
											break;
										}
									}
									if (hasReqs && !(research[r].count >= research[r].max)) {
										toAdd += '<div id="' + r.replace(/ /g, "_") + '">' + r + ' ' + research[r].count + ' ' + Math.ceil(research[r].researchProgress) + '/' + Math.ceil(research[r].researchTime) + '</div>';
									}
								}
								return toAdd;
							});*/
							$(".slot .spellInfo").html( (e) => { // updates spell slot info
								var spellSlot = game.player.spells[e];
								if (spellSlot.unlocked) {
									var spell = calculateSpellAttributes(spellSlot.attributes);
									return Math.floor(spell.damage) + " damage<br>" + Math.floor(spell.cost) + " mana";
								}
								return "None";
							});
							$("#menu_options div").click( function(e) {
								game.player.currentResearch = e.currentTarget.id.replace(/_/g, " ");
								game.player.currentAction = RESEARCHING;
							});
						} else if (game.player.activeTab == CONSTRUCTING) {
							$("#menu_options").html( getActiveTabUI(game.construct) );
							/*() => { backup function
								var construct = game.construct;
								var toAdd = "";
								for (var c in construct) {
									var hasReqs = true;
									for (var reqs in construct[c].requirements) {
										if (!construct[c].requirements[reqs]()) {
											hasReqs = false;
											break;
										}
									}
									if (hasReqs && !(construct[c].count >= construct[c].max)) {
										toAdd += '<div id="' + c.replace(/ /g, "_") + '">' + c + ' ' + construct[c].count + ' ' + construct[c].constructionProgress + '/' + Math.ceil(construct[c].constructionTime) + '</div>';
									}
								}
								return toAdd;
							});*/
							$("#menu_options div").click( function(e) {
								var con = e.currentTarget.id.replace(/_/g, " ");
								if (!game.player.currentConstruction && startConstruction(con)) {
									game.player.currentConstruction = con;
									game.player.currentAction = CONSTRUCTING;
								} else if (game.player.currentConstruction) {
									game.player.currentAction = CONSTRUCTING;
								}
							});
						}
						game.mechanics.refresh_delay = 1;
					} else {
						game.mechanics.refresh_delay++;
					}
					
					
					
					$("#enemyHealth_info").html(Math.floor(enemy.hp.current) + "/" + enemy.hp.max);
					$("#enemyHealth").css("width", (enemy.hp.current / enemy.hp.max) * 100 + "%");
					$("#playerHealth_info").html(Math.floor(player.hp.current) + "/" + player.hp.max);
					$("#playerHealth").css("width", (player.hp.current / player.hp.max) * 100 + "%");
					$("#playerMana_info").html(Math.floor(player.mana.current) + "/" + Math.floor(player.mana.max) + " (+" + Math.floor(player.mana.regenFlat + (player.mana.max * player.mana.regenMax) + (player.mana.current * player.mana.regenCurrent)) + ")" );
					$("#playerMana").css("width", (player.mana.current / player.mana.max) * 100 + "%");
				
						
				}
				$(".btn").click( function (e) {
					game.player.activeTab = e.currentTarget.id == "CONSTRUCTING" ? CONSTRUCTING : RESEARCHING;
				});
				
				
				setInterval(update, game.mechanics.tick_rate);
			});
		</script>
		<style>
			#cast {
				display:inline-block;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div id = "enemy">
			<div id = "enemyHealth_info"></div>
			<div id = "enemyHealth"></div>
			<div id = "enemyHealth_max"></div>
		</div>
		<div id = "player">
			<div id = "menu_options"></div>
			<div id = "menu">
				<div id = "RESEARCHING" class="btn">Research</div>
				<div id = "spells" class="btn">Spells</div>
				<div id = "CONSTRUCTING" class="btn">Construction</div>
			</div>
			<div id = "playerStats">
				<div id = "playerHealth_info"></div>
				<div id = "playerHealth"></div>
				<div id = "playerHealth_max"></div>
				<div id = "playerMana_info"></div>
				<div id = "playerMana"></div>
				<div id = "playerMana_max"></div>
			</div>
			<div id = "playerSpells">
				<div class = "slot" id = "0">
					1<br>
					<span class="spellInfo">2 Damage<br>15 Mana</span>
				</div>
				<div class = "slot" id = "1">
					2<br>
					<span class="spellInfo">None</span>
				</div>
				<div class = "slot" id = "2">
					3<br>
					<span class="spellInfo">None</span>
				</div>
				<div class = "slot" id = "3">
					4<br>
					<span class="spellInfo">None</span>
				</div>
			</div>
		</div>
	</body>
</html>
